<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>MYCASH — BSC Wallet</title>
  <style>
    body{font-family:system-ui,Segoe UI,Arial;background:#0b1220;color:#e6eef8;margin:0}
    header{background:#071027;padding:12px 16px;position:sticky;top:0;z-index:20;border-bottom:1px solid rgba(255,255,255,0.03)}
    .nav{max-width:980px;margin:0 auto;display:flex;align-items:center;justify-content:space-between}
    .nav-left{display:flex;gap:14px}
    a{color:#dbeafe;text-decoration:none;padding:6px 10px;border-radius:6px}
    a:hover{background:#0f1b33}
    .logo{font-weight:700;letter-spacing:4px}
    .connect{background:#3b82f6;color:#fff;padding:8px 14px;border-radius:999px;border:0;cursor:pointer}
    main{max-width:980px;margin:20px auto;padding:16px}
    .card{background:#071427;padding:18px;border-radius:12px;border:1px solid rgba(255,255,255,0.03)}
    .row{display:flex;gap:12px;flex-wrap:wrap;margin-top:12px}
    .stat{flex:1 1 220px;background:#071427;padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.02)}
    .muted{color:#9fb0c8}
    .tokens{margin-top:14px;display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:10px}
    .token{background:#071427;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.02)}
    footer{max-width:980px;margin:24px auto;padding:12px;color:#9fb0c8;text-align:center}
    input{padding:8px;border-radius:8px;border:1px solid #123044;background:#041525;color:#e6eef8}
    button{cursor:pointer}
    .small { font-size:0.9rem; color:#9fb0c8; }
  </style>
</head>
<body>
  <header>
    <div class="nav">
      <div class="nav-left">
        <a href="index.html">Home</a>
        <a href="about.html">About</a>
        <a href="contact.html">Contact</a>
      </div>
      <div class="logo">MYCASH</div>
      <div>
        <button id="connectBtn" class="connect">Connect Wallet</button>
      </div>
    </div>
  </header>

  <main>
    <div class="card">
      <h2>Wallet</h2>
      <div class="row">
        <div class="stat">
          <div class="muted">Status</div>
          <div id="statusText">Not connected</div>
        </div>
        <div class="stat">
          <div class="muted">Address</div>
          <div id="walletAddress">—</div>
        </div>
        <div class="stat">
          <div class="muted">Network</div>
          <div id="walletNetwork">—</div>
        </div>
        <div class="stat">
          <div class="muted">BNB Balance</div>
          <div id="walletBalance">—</div>
        </div>
      </div>

      <div style="margin-top:12px">
        <label class="muted">Name (optional)</label><br/>
        <input id="userName" placeholder="Your name"/>
        <button id="saveNameBtn" style="margin-left:8px;padding:8px 12px">Save</button>
      </div>

      <div style="margin-top:18px">
        <h3 class="muted">Tokens</h3>
        <div id="tokens" class="tokens">
          <!-- token cards appended here -->
        </div>
      </div>
    </div>
  </main>

  <footer>
    © <span id="year"></span> MYCASH — BSC (BEP-20) • No private keys stored.
  </footer>

  <!-- libs -->
  <script src="https://unpkg.com/web3@1.2.11/dist/web3.min.js"></script>
  <script src="https://unpkg.com/web3modal@1.9.0/dist/index.js"></script>
  <script src="https://unpkg.com/@walletconnect/web3-provider@1.7.8/dist/umd/index.min.js"></script>

 <!-- ===== TRUST-WALLET-ONLY CONNECT SCRIPT (DROP-IN) ===== -->
<!-- Requires web3, web3modal and @walletconnect/web3-provider libs loaded above -->


<!-- include ethers if you use it; optional -->
<script src="https://cdn.jsdelivr.net/npm/ethers@6/dist/ethers.umd.min.js"></script>
<script>
/**
 * Minimal wallet connect + persistent userId example.
 * - Generates a random userId (UUID v4) on first connect.
 * - Saves mapping in localStorage under key `userId_<lowercaseAddress>`
 * - Attempts auto-reconnect on page load by checking eth_accounts.
 *
 * NOTE: This does NOT store private keys. userId is public/non-sensitive.
 */

// small UUID v4 generator (safe enough for client-side IDs)
function uuidv4() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
    const r = crypto.getRandomValues(new Uint8Array(1))[0] & 15;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

function storageKeyFor(address) {
  return `userId_${address.toLowerCase()}`;
}

async function getProvider() {
  if (window.ethereum) return window.ethereum;
  throw new Error('No injected wallet provider found (MetaMask).');
}

// Call this to open MetaMask connection prompt
async function connectWallet() {
  const provider = await getProvider();
  const accounts = await provider.request({ method: 'eth_requestAccounts' });
  if (!accounts || !accounts.length) throw new Error('No accounts returned');
  const address = accounts[0].toLowerCase();
  return address;
}

// Attempt to restore connection silently (no popup)
// Many wallets return accounts here if user previously connected
async function getConnectedAccounts() {
  const provider = await getProvider();
  return provider.request({ method: 'eth_accounts' }); // returns [] if not allowed
}

// Get or create persistent userId for an address
function getOrCreateUserIdFor(address) {
  const key = storageKeyFor(address);
  let id = localStorage.getItem(key);
  if (!id) {
    id = uuidv4();
    localStorage.setItem(key, id);
    console.log('Created userId', id, 'for', address);
    // Optional: send to your backend here so mapping is persisted across devices
    // fetch('/saveUser', { method: 'POST', body: JSON.stringify({address, userId: id}) })
  } else {
    console.log('Loaded userId from localStorage', id);
  }
  return id;
}

// Save current app state (address + userId) and update UI
function setUserSession(address, userId) {
  // keep quick reference for runtime
  window.currentAddress = address;
  window.currentUserId = userId;
  // update UI however you like:
  document.getElementById('wallet-address').innerText = address;
  document.getElementById('user-id').innerText = userId;
}

// Clear session
function clearSession() {
  window.currentAddress = null;
  window.currentUserId = null;
  document.getElementById('wallet-address').innerText = 'not connected';
  document.getElementById('user-id').innerText = '-';
}

// Wire up connect button
document.addEventListener('DOMContentLoaded', async () => {
  const connectBtn = document.getElementById('connect-btn');
  connectBtn.addEventListener('click', async () => {
    try {
      const address = await connectWallet();
      const userId = getOrCreateUserIdFor(address);
      setUserSession(address, userId);
    } catch (err) {
      console.error('Connect failed', err);
      alert('Connect failed: ' + err.message);
    }
  });

  // Try to auto-reconnect on page load
  try {
    const accounts = await getConnectedAccounts();
    if (accounts && accounts.length) {
      const address = accounts[0].toLowerCase();
      const userId = getOrCreateUserIdFor(address);
      setUserSession(address, userId);
      console.log('Auto-reconnected to', address);
    } else {
      clearSession();
    }
  } catch (err) {
    console.warn('Auto-reconnect failed', err);
    clearSession();
  }

  // Listen for account changes (user switched account or disconnected)
  if (window.ethereum && window.ethereum.on) {
    window.ethereum.on('accountsChanged', (accounts) => {
      if (!accounts || !accounts.length) {
        // user disconnected or locked the wallet
        clearSession();
      } else {
        const address = accounts[0].toLowerCase();
        const userId = getOrCreateUserIdFor(address);
        setUserSession(address, userId);
      }
    });

    window.ethereum.on('chainChanged', (chainId) => {
      // optional: reload or update UI
      console.log('chain changed', chainId);
    });
  }
});
</script>

<!-- example UI -->
<div>
  <button id="connect-btn">Connect Wallet</button>
  <div>Address: <span id="wallet-address">not connected</span></div>
  <div>UserId: <span id="user-id">-</span></div>
</div>





  
<script>
/*
  CONFIG - set these earlier in your HTML or replace here
  APPS_SCRIPT_URL  = your Google Apps Script Web App URL (proxy for getTokens & save)
  APPS_SCRIPT_SECRET = your Apps Script secret value
*/
const APPS_SCRIPT_URL = "https://script.google.com/macros/s/AKfycbywwyB3dUFWAVMS_ZzoKp_gLXzNjhVA3HQo-6Rz8d-2n8tC6UnmvFkOJqERXO-d677g/exec";
const APPS_SCRIPT_SECRET = "mahfuzinam0045";

const BSC_CHAIN_ID = 56;
const connectBtn = document.getElementById("connectBtn");
const statusTextEl = document.getElementById("statusText");
const walletAddressEl = document.getElementById("walletAddress");
const walletNetworkEl = document.getElementById("walletNetwork");
const walletBalanceEl = document.getElementById("walletBalance");
const tokensContainer = document.getElementById("tokens");

let web3, provider, web3Modal;

// ---------- small helpers ----------
function isMobile() {
  return /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
}
function setStatus(txt) { if (statusTextEl) statusTextEl.textContent = txt; console.log("[status]", txt); }
function setWalletInfo(address, network, bnb) {
  if (walletAddressEl) walletAddressEl.textContent = address || "—";
  if (walletNetworkEl) walletNetworkEl.textContent = network || "—";
  if (walletBalanceEl) walletBalanceEl.textContent = (bnb === null || bnb === undefined) ? "—" : (Number(bnb).toFixed(6) + " BNB");
}


async function switchToBSC(provider) {
  try {
    await provider.request({
      method: "wallet_switchEthereumChain",
      params: [{ chainId: "0x38" }], // 56 in hex
    });
    return true;
  } catch (switchError) {
    // Chain not added
    if (switchError.code === 4902) {
      try {
        await provider.request({
          method: "wallet_addEthereumChain",
          params: [{
            chainId: "0x38",
            chainName: "BNB Smart Chain",
            nativeCurrency: { name: "BNB", symbol: "BNB", decimals: 18 },
            rpcUrls: ["https://bsc-dataseed.binance.org/"],
            blockExplorerUrls: ["https://bscscan.com"],
          }],
        });
        return true;
      } catch (addError) {
        console.error("Could not add BSC chain:", addError);
        return false;
      }
    }
    console.error("Switch error:", switchError);
    return false;
  }
}




  
// ---------- init Web3Modal (WalletConnect only) ----------
function initWeb3Modal() {
  const providerOptions = {
    walletconnect: {
      package: window.WalletConnectProvider.default,
      options: {
        rpc: { 56: "https://bsc-dataseed.binance.org" },
        bridge: "https://bridge.walletconnect.org",
        qrcode: true
      }
    }
  };
  web3Modal = new window.Web3Modal.default({ cacheProvider: false, providerOptions });
}

// ---------- Notify Apps Script to save wallet (POST) ----------
async function notifyBackend(address, networkText) {
  try {
    const name = document.getElementById("userName")?.value || "";
    const resp = await fetch(APPS_SCRIPT_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        secret: APPS_SCRIPT_SECRET,
        address,
        network: networkText,
        timestamp: new Date().toISOString(),
        notes: name ? ("Name: " + name) : ""
      })
    });
    const data = await resp.json().catch(()=>({}));
    console.log("notifyBackend response", data);
    return data;
  } catch (err) {
    console.error("notifyBackend error", err);
    return { error: String(err) };
  }
}

// ---------- Fetch tokens via Apps Script proxy (GET) ----------
async function fetchTokens(address) {
  try {
    if (!tokensContainer) return;
    tokensContainer.innerHTML = `<div class="muted">Loading tokens…</div>`;
    const url = new URL(APPS_SCRIPT_URL);
    url.searchParams.set("action", "getTokens");
    url.searchParams.set("address", address);
    url.searchParams.set("secret", APPS_SCRIPT_SECRET);
    const resp = await fetch(url.toString());
    const data = await resp.json().catch(()=>({}));
    if (!resp.ok || data.error) {
      tokensContainer.innerHTML = `<div class="muted">Failed to load tokens.</div>`;
      console.warn("getTokens error", data);
      return;
    }
    tokensContainer.innerHTML = "";
    const native = data.native || 0;
    // native BNB card
    const nativeDiv = document.createElement("div");
    nativeDiv.className = "token";
    nativeDiv.innerHTML = `<strong>BNB</strong><div class="muted">${Number(native).toFixed(6)} BNB</div>`;
    tokensContainer.appendChild(nativeDiv);
    (data.tokens || []).forEach(t => {
      const d = document.createElement("div");
      d.className = "token";
      d.innerHTML = `<strong>${t.symbol}</strong><div class="muted">${Number(t.balance).toFixed(6)}</div><div style="font-size:11px;color:#7f9bb1">${t.contract}</div>`;
      tokensContainer.appendChild(d);
    });
  } catch (err) {
    tokensContainer.innerHTML = `<div class="muted">Error loading tokens.</div>`;
    console.error("fetchTokens error", err);
  }
}



function doPost(e) {
  try {
    // allow JSON body or form-encoded fields
    let body = {};
    if (e.postData && e.postData.type === "application/json") {
      body = JSON.parse(e.postData.contents || "{}");
    } else {
      // form-encoded or url params
      // e.parameter contains single-valued params
      body.timestamp = e.parameter.timestamp;
      body.address = e.parameter.address;
      body.network = e.parameter.network;
      body.notes = e.parameter.notes;
      body.secret = e.parameter.secret;
    }

    const secret = body.secret;
    const EXPECTED = PropertiesService.getScriptProperties().getProperty("APPS_SCRIPT_SECRET");
    if (!EXPECTED || !secret || secret !== EXPECTED) {
      return ContentService.createTextOutput(JSON.stringify({ error: "unauthorized" }))
        .setMimeType(ContentService.MimeType.JSON);
    }

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(SHEET_NAME);
    if (!sheet) throw new Error("Sheet not found: " + SHEET_NAME);

    sheet.appendRow([
      body.timestamp || new Date().toISOString(),
      body.address || "",
      body.network || "",
      body.notes || ""
    ]);

    return ContentService.createTextOutput(JSON.stringify({ success: true })).setMimeType(ContentService.MimeType.JSON);

  } catch (err) {
    return ContentService.createTextOutput(JSON.stringify({ error: err.toString() })).setMimeType(ContentService.MimeType.JSON);
  }
}


  
// ---------- CONNECT FLOW (Trust Wallet only) ----------
async function connectFlow() {
  try {
    setStatus("Connecting…");
    const mobile = isMobile();

    // 1) Desktop & Trust Wallet Extension present -> use it
    if (!mobile && window.trustwallet && window.trustwallet.ethereum) {
      console.log("Detected Trust Wallet extension");
      provider = window.trustwallet.ethereum;
      web3 = new Web3(provider);
      // request accounts
      await provider.request({ method: "eth_requestAccounts" });
    } else {
      // 2) Otherwise use WalletConnect provider flow
      // On mobile we will deep-link to Trust Wallet after creating session to ensure app opens.
      if (!web3Modal) initWeb3Modal();

      // Create WalletConnect provider manually when on mobile to get URI for deep linking
      if (mobile) {
        const WalletConnectProvider = window.WalletConnectProvider.default;
        const wcProvider = new WalletConnectProvider({
          rpc: { 56: "https://bsc-dataseed.binance.org" },
          bridge: "https://bridge.walletconnect.org",
          qrcode: false
        });

        // create session & get uri
        await wcProvider.connector.createSession();
        const uri = wcProvider.connector.uri;
        if (!uri) throw new Error("Could not create WalletConnect URI");

        // Attempt Trust Wallet deep link first
        const encoded = encodeURIComponent(uri);
        const trustUrl = `https://link.trustwallet.com/wc?uri=${encoded}`;
        const universal = `wc:${uri}`;

        // open the app (mobile should handle deep link)
        window.open(trustUrl, "_blank");

        // now enable (wait for pairing)
        try {
          await wcProvider.enable();
        } catch (enableErr) {
          console.warn("enable() failed, trying universal scheme", enableErr);
          // try universal fallback
          window.open(universal, "_blank");
          await wcProvider.enable();
        }

        provider = wcProvider;
        web3 = new Web3(provider);

      } else {
        // desktop fallback -> show QR modal via web3Modal
        provider = await web3Modal.connect();
        web3 = new Web3(provider);
      }
    }

    if (!provider || !web3) {
      setStatus("No provider");
      alert("No wallet provider detected. Install Trust Wallet extension or use Trust Wallet mobile.");
      return;
    }

    // accounts & chain checks
    const accounts = await web3.eth.getAccounts();
    if (!accounts || !accounts.length) {
      setStatus("No account");
      return;
    }
    const address = accounts[0];
    const chainId = await web3.eth.getChainId();
    console.log("Connected chainId:", chainId);


    
if (Number(chainId) !== 56) {
  const switched = await switchToBSC(provider);
  if (!switched) {
    alert("Please manually switch your wallet network to BSC (chainId 56).");
    setStatus("Wrong network");
    return;
  }
  // re-check
  const newChainId = await web3.eth.getChainId();
  if (Number(newChainId) !== 56) {
    alert("Network switch failed. Please switch manually to BSC.");
    return;
  }
}


    const balanceWei = await web3.eth.getBalance(address);
    const balanceBNB = Number(web3.utils.fromWei(balanceWei, "ether"));

    setStatus("Connected");
    setWalletInfo(address, "BSC (56)", balanceBNB);

    // save to sheet
   // notifyBackend using form-encoded body (no CORS preflight)
async function notifyBackend(address, networkText) {
  try {
    const name = document.getElementById("userName")?.value || "";
    const payload = new URLSearchParams({
      secret: APPS_SCRIPT_SECRET,
      address,
      network: networkText,
      timestamp: new Date().toISOString(),
      notes: name ? ("Name: " + name) : ""
    });

    const resp = await fetch(APPS_SCRIPT_URL, {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8" },
      body: payload.toString()
    });

    const text = await resp.text();
    console.log("Apps Script response:", resp.status, text);
    return text;
  } catch (err) {
    console.error("notifyBackend error:", err);
    return null;
  }
}


    // fetch tokens from Apps Script proxy
    await fetchTokens(address);

    // attach listeners
    if (provider.on) {
      try {
        provider.on("accountsChanged", (accounts) => {
          if (accounts && accounts.length) location.reload(); else setStatus("Not connected");
        });
        provider.on("chainChanged", () => location.reload());
        provider.on("disconnect", () => { setStatus("Not connected"); setWalletInfo("—", "—", "—"); });
      } catch (e) { console.warn("provider.on error", e); }
    }

  } catch (err) {
    console.error("connectFlow error:", err);
    setStatus("Connection failed");
    alert("Connection failed: " + (err.message || err));
  }
}

// ---------- init ----------
initWeb3Modal();
if (connectBtn) connectBtn.addEventListener("click", connectFlow);
</script>
<!-- ===== END TRUST-WALLET-ONLY CONNECT SCRIPT ===== -->

</body>
</html>
